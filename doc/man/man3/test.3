.TH "test" 3 "MoshLib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
test
.SH SYNOPSIS
.br
.PP
.SS "Функции"

.in +1c
.ti -1c
.RI "void \fBlines\fP (uint16_t &ret_L, uint16_t &ret_R, uint32_t timeout=1000)"
.br
.RI "Измерить значения датчиков линий "
.ti -1c
.RI "void \fBmotorsAccel\fP ()"
.br
.RI "тест функциональности моторов "
.ti -1c
.RI "void \fBmotorsPWM\fP ()"
.br
.RI "тест функциональности моторов (ШИМ ВЕРСИЯ) "
.in -1c
.SH "Функции"
.PP 
.SS "void test::lines (uint16_t & ret_L, uint16_t & ret_R, uint32_t timeout = \fR1000\fP)"

.PP
Измерить значения датчиков линий 
.PP
\fBАргументы\fP
.RS 4
\fIret_L\fP возврат для левого 
.br
\fIret_R\fP возврат для правого 
.br
\fItimeout\fP время измерения 
.RE
.PP
.PP
.nf
102                                                                    {
103     uint16_t i;
104     uint32_t sum_L = 0, sum_R = 0;
105     timeout += millis();
106 
107     for (i = 0; millis() < timeout; i++) {
108         sum_L += lineL\&.readRaw();
109         sum_R += lineR\&.readRaw();
110     }
111 
112     ret_L = sum_L / i;
113     ret_R = sum_R / i;
114 }
.fi

.SS "void test::motorsAccel ()"

.PP
тест функциональности моторов .PP
.nf
130                        {
131     MotorEncoder* _motors[]{ &motorL, &motorR };
132 
133     for (MotorEncoder* m : _motors) {
134         test_motors_speed(m, 1);
135         test_motors_speed(m, \-1);
136     }
137 }
.fi

.SS "void test::motorsPWM ()"

.PP
тест функциональности моторов (ШИМ ВЕРСИЯ) .PP
.nf
139                      {
140     MotorEncoder* _motors[]{ &motorL, &motorR };
141 
142     for (MotorEncoder* motor : _motors) {
143         for (int16_t i = \-255; i < 256; i++) {
144             motor\->setPWM(255 \- abs(i));
145             motor\->setDir(i > 0);
146             delay(2 * 2000 / 256);
147         }
148         motor\->setPWM(0);
149         delay(500);
150     }
151 }
.fi

.SH "Автор"
.PP 
Автоматически создано Doxygen для MoshLib из исходного текста\&.
