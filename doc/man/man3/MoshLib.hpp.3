.TH "src/MoshLib.hpp" 3 "MoshLib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/MoshLib.hpp
.SH SYNOPSIS
.br
.PP
\fR#include 'core\\config\&.hpp'\fP
.br
\fR#include 'core/enviroment\&.hpp'\fP
.br
\fR#include 'control/move\&.hpp'\fP
.br

.SS "Пространства имен"

.in +1c
.ti -1c
.RI "namespace \fBtest\fP"
.br
.in -1c
.SS "Функции"

.in +1c
.ti -1c
.RI "void \fBsetDistL\fP (\fBmosh::hardware::DistanceSensor\fP &sensor)"
.br
.RI "Указать ЛЕВЫЙ датчик расстояния "
.ti -1c
.RI "void \fBsetDistR\fP (\fBmosh::hardware::DistanceSensor\fP &sensor)"
.br
.RI "Указать ПРАВЫЙ датчик расстояния "
.ti -1c
.RI "void \fBsetDistF\fP (\fBmosh::hardware::DistanceSensor\fP &sensor)"
.br
.RI "Указать ПЕРЕДНИЙ датчик расстояния "
.ti -1c
.RI "void \fBgoTime\fP (uint32_t runtime, int8_t speed_left, int8_t speed_right, bool __hold_at_end=true)"
.br
.RI "Движение с заданой скоростью на время "
.ti -1c
.RI "void \fBgoTime\fP (uint32_t runtime, int8_t speed=\fBDEFAULT_SPEED_TICK\fP)"
.br
.RI "Движение с заданой скоростью на время "
.ti -1c
.RI "void \fBgoHold\fP (uint32_t timeout=\fBHOLD_STOP_TIMEOUT\fP)"
.br
.RI "Удерживать моторы в текущем положении на время "
.ti -1c
.RI "void \fBgoTick\fP (int32_t ticks, uint8_t speed=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "на число тиков "
.ti -1c
.RI "void \fBgoDist\fP (int32_t distance_mm, int16_t speed_PWM=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "Прямолинейное синхронное движение "
.ti -1c
.RI "void \fBgoCross\fP (uint8_t crosses=1, bool found_line=false, int16_t speed_PWMDIR=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "Прямолинейное синхронное движение до перекрёстка "
.ti -1c
.RI "void \fBturnAngle\fP (int16_t a, int16_t speed=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "синхронный Поворот на заданый угол вокруг центра "
.ti -1c
.RI "void \fBalignLine\fP (uint32_t duration=\fBPARAMS::ALIGN_DURATION\fP)"
.br
.RI "Выровнять робота по линии "
.ti -1c
.RI "void \fBturnLineL\fP (int8_t crosses=1, int16_t speed=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "повернуться вокруг центра влево пересекая линии "
.ti -1c
.RI "void \fBturnLineR\fP (int8_t crosses=1, int16_t speed=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "повернуться вокруг центра направо по перекрёсткам "
.ti -1c
.RI "void \fBwallFront\fP (\fBmosh::hardware::DistanceSensor\fP &sensor, uint8_t distance, uint8_t speed=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "Прямолинейное синхронное движение до стены (любой датчик) "
.ti -1c
.RI "void \fBwallFront\fP (uint8_t distance, uint8_t speed=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "Прямолинейное синхронное движение до стены (передний датчик) "
.ti -1c
.RI "void \fBwallBack\fP (\fBmosh::hardware::DistanceSensor\fP &sensor, uint8_t distance, int16_t speed=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "Прямолинейное синхронное движение назад от стены (любой датчик) "
.ti -1c
.RI "void \fBwallBack\fP (uint8_t distance, uint8_t speed=\fBDEFAULT_SPEED_PWM\fP)"
.br
.RI "Прямолинейное синхронное движение назад от стены (передний датчик) "
.ti -1c
.RI "void \fBwallTimeL\fP (uint8_t distance, uint32_t runtime, uint8_t speed=\fBDEFAULT_SPEED_TICK\fP)"
.br
.RI "Движение вдоль стены по ЛЕВОМУ датчику "
.ti -1c
.RI "void \fBwallTimeR\fP (uint8_t distance, uint32_t runtime, uint8_t speed=\fBDEFAULT_SPEED_TICK\fP)"
.br
.RI "Движение вдоль стены по ПРАВОМУ датчику "
.ti -1c
.RI "void \fBlineTimeL\fP (uint32_t runtime, uint8_t speed=\fBDEFAULT_SPEED_TICK\fP)"
.br
.RI "движение по линии по левому датчику "
.ti -1c
.RI "void \fBlineTimeR\fP (uint32_t runtime, uint8_t speed=\fBDEFAULT_SPEED_TICK\fP)"
.br
.RI "движение по линии по правому датчику "
.ti -1c
.RI "void \fBlineTimeLR\fP (uint32_t runtime, uint8_t speed=\fBDEFAULT_SPEED_TICK\fP)"
.br
.RI "движение по линии по двум датчикам "
.ti -1c
.RI "void \fBlineTimeP\fP (uint32_t runtime, uint8_t speed=\fBDEFAULT_SPEED_TICK\fP)"
.br
.RI "движение по линии по P-регулятору "
.ti -1c
.RI "void \fBlineCrossP\fP (uint8_t crosses=1, uint8_t speed=\fBDEFAULT_SPEED_TICK\fP)"
.br
.RI "Движение по линии до перекрёстка P-регулятор "
.ti -1c
.RI "void \fBlineDistP\fP (int32_t distance, uint8_t speed=\fBDEFAULT_SPEED_TICK\fP)"
.br
.RI "Движение по линии на расстояние P-регулятор "
.ti -1c
.RI "void \fBtest::lines\fP (uint16_t &ret_L, uint16_t &ret_R, uint32_t timeout=1000)"
.br
.RI "Измерить значения датчиков линий "
.ti -1c
.RI "void \fBtest::motorsAccel\fP ()"
.br
.RI "тест функциональности моторов "
.ti -1c
.RI "void \fBtest::motorsPWM\fP ()"
.br
.RI "тест функциональности моторов (ШИМ ВЕРСИЯ) "
.in -1c
.SH "Функции"
.PP 
.SS "void alignLine (uint32_t duration = \fR\fBPARAMS::ALIGN_DURATION\fP\fP)"

.PP
Выровнять робота по линии 
.PP
\fBАргументы\fP
.RS 4
\fIduration\fP время выравнивания 
.RE
.PP
.PP
.nf
49 { run::time(LineProp(0), duration); }
.fi

.SS "void goCross (uint8_t crosses = \fR1\fP, bool found_line = \fRfalse\fP, int16_t speed_PWMDIR = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
Прямолинейное синхронное движение до перекрёстка 
.PP
\fBАргументы\fP
.RS 4
\fIcrosses\fP кол-во перекрёстков 
.br
\fIfound_line\fP искомое состояние 
.br
\fIspeed_PWMDIR\fP скорость (отрицательная - движение назад) 
.RE
.PP
.PP
.nf
40 { run::base(Sync(speed_PWMDIR), LineFound(LineFound::LINE_BOTH, crosses, found_line)); }
.fi

.SS "void goDist (int32_t distance_mm, int16_t speed_PWM = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
Прямолинейное синхронное движение 
.PP
\fBАргументы\fP
.RS 4
\fIdistance_mm\fP расстояние (отрицательное - едет назад) 
.br
\fIspeed_PWM\fP скорость движения ШИМ 
.RE
.PP
.PP
.nf
35                                                 {
36     if (distance_mm < 0) speed *= \-1;
37     run::base(Sync(speed), DistanceMoved(distance_mm));
38 }
.fi

.SS "void goHold (uint32_t timeout = \fR\fBHOLD_STOP_TIMEOUT\fP\fP)"

.PP
Удерживать моторы в текущем положении на время 
.PP
\fBАргументы\fP
.RS 4
\fItimeout\fP время удержания 
.RE
.PP
.PP
.nf
31 { goTime(timeout, 0, 0, false); }
.fi

.SS "void goTick (int32_t ticks, uint8_t speed = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
на число тиков 
.PP
\fBАргументы\fP
.RS 4
\fIspeed\fP ШИМ скорость движения 
.RE
.PP
.PP
.nf
33 { run::base(Sync(speed), DistanceMoved(ticks, ticks, false)); }
.fi

.SS "void goTime (uint32_t runtime, int8_t speed = \fR\fBDEFAULT_SPEED_TICK\fP\fP)"

.PP
Движение с заданой скоростью на время 
.PP
\fBАргументы\fP
.RS 4
\fIruntime\fP время работы 
.br
\fIspeed\fP скорость 
.RE
.PP
.PP
.nf
29 { goTime(runtime, speed, speed); }
.fi

.SS "void goTime (uint32_t runtime, int8_t speed_left, int8_t speed_right, bool __hold_at_end = \fRtrue\fP)"

.PP
Движение с заданой скоростью на время 
.PP
\fBАргументы\fP
.RS 4
\fIruntime\fP время работы 
.br
\fIspeed_left\fP скорость левого мотора 
.br
\fIspeed_right\fP скорость правого мотора 
.br
\fI__hold_at_end\fP удержание моторов в конце движения (для реализации goHold) 
.RE
.PP
.PP
.nf
25                                                                                          {
26     run::base(KeepSpeed(speed_left, speed_right), OnTimer(runtime), __hold_at_end);
27 }
.fi

.SS "void lineCrossP (uint8_t crosses = \fR1\fP, uint8_t speed = \fR\fBDEFAULT_SPEED_TICK\fP\fP)"

.PP
Движение по линии до перекрёстка P-регулятор 
.PP
\fBАргументы\fP
.RS 4
\fIcrosses\fP на каком перекрёстке остановиться 
.br
\fIspeed\fP скорость ТИК 
.RE
.PP
.PP
.nf
97 { run::base(LineProp(speed), LineFound(LineFound::LINE_BOTH, crosses, false)); }
.fi

.SS "void lineDistP (int32_t distance, uint8_t speed = \fR\fBDEFAULT_SPEED_TICK\fP\fP)"

.PP
Движение по линии на расстояние P-регулятор 
.PP
\fBАргументы\fP
.RS 4
\fIdistance\fP Расстояние движения 
.br
\fIspeed\fP скорость ТИК 
.RE
.PP
.PP
.nf
99 { run::base(LineProp(speed), DistanceMoved(distance)); }
.fi

.SS "void lineTimeL (uint32_t runtime, uint8_t speed = \fR\fBDEFAULT_SPEED_TICK\fP\fP)"

.PP
движение по линии по левому датчику 
.PP
\fBАргументы\fP
.RS 4
\fIspeed\fP скорость 
.RE
.PP
.PP
.nf
88 { run::time(LineRelay(LineRelay::LINE_LEFT, speed), runtime); }
.fi

.SS "void lineTimeLR (uint32_t runtime, uint8_t speed = \fR\fBDEFAULT_SPEED_TICK\fP\fP)"

.PP
движение по линии по двум датчикам 
.PP
\fBАргументы\fP
.RS 4
\fIspeed\fP скорость 
.RE
.PP
.PP
.nf
92 { run::time(LineRelay2(speed), runtime); }
.fi

.SS "void lineTimeP (uint32_t runtime, uint8_t speed = \fR\fBDEFAULT_SPEED_TICK\fP\fP)"

.PP
движение по линии по P-регулятору 
.PP
\fBАргументы\fP
.RS 4
\fIspeed\fP скорость 
.RE
.PP
.PP
.nf
94 { run::time(LineProp(speed), runtime); }
.fi

.SS "void lineTimeR (uint32_t runtime, uint8_t speed = \fR\fBDEFAULT_SPEED_TICK\fP\fP)"

.PP
движение по линии по правому датчику 
.PP
\fBАргументы\fP
.RS 4
\fIspeed\fP скорость 
.RE
.PP
.PP
.nf
90 { run::time(LineRelay(LineRelay::LINE_RIGHT, speed), runtime); }
.fi

.SS "void setDistF (\fBmosh::hardware::DistanceSensor\fP & sensor)"

.PP
Указать ПЕРЕДНИЙ датчик расстояния 
.PP
\fBАргументы\fP
.RS 4
\fIsensor\fP ссылка на датчик 
.RE
.PP
.PP
.nf
16 { robot\&.dist_front = &sensor; }
.fi

.SS "void setDistL (\fBmosh::hardware::DistanceSensor\fP & sensor)"

.PP
Указать ЛЕВЫЙ датчик расстояния 
.PP
\fBАргументы\fP
.RS 4
\fIsensor\fP ссылка на датчик 
.RE
.PP
.PP
.nf
12 { robot\&.dist_left = &sensor; }
.fi

.SS "void setDistR (\fBmosh::hardware::DistanceSensor\fP & sensor)"

.PP
Указать ПРАВЫЙ датчик расстояния 
.PP
\fBАргументы\fP
.RS 4
\fIsensor\fP ссылка на датчик 
.RE
.PP
.PP
.nf
14 { robot\&.dist_right = &sensor; }
.fi

.SS "void turnAngle (int16_t a, int16_t speed = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
синхронный Поворот на заданый угол вокруг центра 
.PP
\fBАргументы\fP
.RS 4
\fIa\fP угол поворота ( <0 - поворот против часовой) 
.br
\fIspeed\fP ШИМ скорось поворота 
.RE
.PP
.PP
.nf
44                                          {
45     int32_t dist = (int32_t) a * (TRACK_SIZE_MM * M_PI / 360\&.0);
46     run::base(Sync(speed, \-speed, 1, \-1), DistanceMoved(dist, \-dist));
47 }
.fi

.SS "void turnLineL (int8_t crosses = \fR1\fP, int16_t speed = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
повернуться вокруг центра влево пересекая линии 
.PP
\fBАргументы\fP
.RS 4
\fIcrosses\fP кол-во линий 
.br
\fIspeed\fP ШИМ скорость 
.RE
.PP
.PP
.nf
56 { __turn_line(crosses, speed, LineFound::LINE_LEFT); }
.fi

.SS "void turnLineR (int8_t crosses = \fR1\fP, int16_t speed = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
повернуться вокруг центра направо по перекрёсткам 
.PP
\fBАргументы\fP
.RS 4
\fIcrosses\fP кол-во линий 
.br
\fIspeed\fP ШИМ скорость 
.RE
.PP
.PP
.nf
58 { __turn_line(crosses, \-speed, LineFound::LINE_RIGHT); }
.fi

.SS "void wallBack (\fBmosh::hardware::DistanceSensor\fP & sensor, uint8_t distance, int16_t speed = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
Прямолинейное синхронное движение назад от стены (любой датчик) 
.PP
\fBАргументы\fP
.RS 4
\fIsensor\fP ссылка на датчик 
.br
\fIdistance\fP расстояние до стены 
.br
\fIspeed\fP ШИМ скорость движения 
.RE
.PP
.PP
.nf
68                                                                            {
69     run::base(Sync(\-speed), DistanceRead(sensor, wall_dist_cm, DistanceRead::LESS));
70 }
.fi

.SS "void wallBack (uint8_t distance, uint8_t speed = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
Прямолинейное синхронное движение назад от стены (передний датчик) 
.PP
\fBАргументы\fP
.RS 4
\fIdistance\fP расстояния, на котором будет стены 
.br
\fIspeed\fP ШИМ скорость движения 
.RE
.PP
.PP
.nf
72 { wallBack(*robot\&.dist_front, distance, speed); }
.fi

.SS "void wallFront (\fBmosh::hardware::DistanceSensor\fP & sensor, uint8_t distance, uint8_t speed = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
Прямолинейное синхронное движение до стены (любой датчик) 
.PP
\fBАргументы\fP
.RS 4
\fIsensor\fP ссылка на датчик 
.br
\fIdistance\fP расстояние до стены 
.br
\fIspeed\fP ШИМ скорость движения 
.RE
.PP
.PP
.nf
62                                                                             {
63     run::base(Sync(speed), DistanceRead(sensor, wall_dist_cm, DistanceRead::GREATER));
64 }
.fi

.SS "void wallFront (uint8_t distance, uint8_t speed = \fR\fBDEFAULT_SPEED_PWM\fP\fP)"

.PP
Прямолинейное синхронное движение до стены (передний датчик) 
.PP
\fBАргументы\fP
.RS 4
\fIdistance\fP расстояние до стены 
.br
\fIspeed\fP ШИМ скорость движения 
.RE
.PP
.PP
.nf
66 { wallFront(*robot\&.dist_front, distance, speed); }
.fi

.SS "void wallTimeL (uint8_t distance, uint32_t runtime, uint8_t speed = \fR\fBDEFAULT_SPEED_TICK\fP\fP)"

.PP
Движение вдоль стены по ЛЕВОМУ датчику 
.PP
\fBАргументы\fP
.RS 4
\fIdistance\fP целевое расстояние в см 
.br
\fIruntime\fP время движения 
.br
\fIspeed\fP скорость 
.RE
.PP
.PP
.nf
74                                                                   {
75     run::time(MoveAlongWall(distance, MoveAlongWall::DIST_LEFT, speed), runtime);
76 }
.fi

.SS "void wallTimeR (uint8_t distance, uint32_t runtime, uint8_t speed = \fR\fBDEFAULT_SPEED_TICK\fP\fP)"

.PP
Движение вдоль стены по ПРАВОМУ датчику 
.PP
\fBАргументы\fP
.RS 4
\fIdistance\fP целевое расстояние в см 
.br
\fIruntime\fP время движения 
.br
\fIspeed\fP скорость 
.RE
.PP
.PP
.nf
78                                                                   {
79     run::time(MoveAlongWall(distance, MoveAlongWall::DIST_RIGHT, speed), runtime);
80 }
.fi

.SH "Автор"
.PP 
Автоматически создано Doxygen для MoshLib из исходного текста\&.
