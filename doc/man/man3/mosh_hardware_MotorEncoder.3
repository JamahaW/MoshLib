.TH "mosh::hardware::MotorEncoder" 3 "MoshLib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mosh::hardware::MotorEncoder \- класс DC-мотор-энкодера, управляемого H-мостом  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <motorencoder\&.hpp>\fP
.SS "Открытые члены"

.in +1c
.ti -1c
.RI "\fBMotorEncoder\fP (void(*encoder_handler)(void), bool inverted, uint8_t pin_speed, uint8_t pin_dir, uint8_t pin_enc_a, uint8_t pin_enc_b)"
.br
.RI "Мотор-Энкодер управляемый H-мостом "
.ti -1c
.RI "void \fBenc\fP ()"
.br
.RI "вызывается исключительно в прерывании "
.ti -1c
.RI "void \fBreset\fP ()"
.br
.RI "сброс "
.ti -1c
.RI "void \fBsetDir\fP (bool backward)"
.br
.RI "Установить направление "
.ti -1c
.RI "void \fBsetPWM\fP (uint8_t pwm)"
.br
.RI "Установить шим "
.ti -1c
.RI "void \fBsetDirPWM\fP (int16_t power)"
.br
.RI "Установить шим-направление\&. Отрицательные значения соотвествуют реверсу\&. ШИМ берётся по модулю и ограничивается\&. "
.ti -1c
.RI "void \fBsetSpeed\fP (int16_t dtick)"
.br
.RI "Установить целевую скорость вращения "
.ti -1c
.RI "void \fBspin\fP ()"
.br
.RI "вращать мотор (вызывать постоянно) "
.in -1c
.SS "Открытые атрибуты"

.in +1c
.ti -1c
.RI "volatile int32_t \fBposition\fP = 0"
.br
.in -1c
.SH "Подробное описание"
.PP 
класс DC-мотор-энкодера, управляемого H-мостом 
.SH "Конструктор(ы)"
.PP 
.SS "MotorEncoder::MotorEncoder (void(*)(void) encoder_handler, bool inverted, uint8_t pin_speed, uint8_t pin_dir, uint8_t pin_enc_a, uint8_t pin_enc_b)"

.PP
Мотор-Энкодер управляемый H-мостом 
.PP
\fBАргументы\fP
.RS 4
\fIencoder_handler\fP обработчик энкодера в прерывании 
.br
\fIinverted\fP глобальная инверсия мотора (направления и энкодер) 
.br
\fIpin_speed\fP пин скорости (ШИМ) 
.br
\fIpin_dir\fP пин скорости (Цифровой) 
.br
\fIpin_enc_a\fP пин основного канала энкодера (Цифровой ПРЕРЫВАНИЕ) 
.br
\fIpin_enc_b\fP пин второго канала энкодера (Цифровой) 
.RE
.PP
.PP
.nf
7     : PIN_SPEED(pin_speed), PIN_DIR(pin_dir), PIN_ENC_B(pin_enc_b), INVERTED(inverted) {
8     pinMode(PIN_SPEED, OUTPUT);
9     pinMode(PIN_DIR, OUTPUT);
10     pinMode(PIN_ENC_B, INPUT);
11     pinMode(pin_enc_a, INPUT);
12     attachInterrupt(digitalPinToInterrupt(pin_enc_a), encoder_handler, FALLING);
13 }
.fi

.SH "Методы"
.PP 
.SS "void MotorEncoder::enc ()"

.PP
вызывается исключительно в прерывании .PP
.nf
15 { position += (digitalRead(PIN_ENC_B) ^ INVERTED) ? (1) : (\-1); }
.fi

.SS "void MotorEncoder::reset ()"

.PP
сброс .PP
.nf
17 { position = next_pos = speed_set = speed = timer = 0; }
.fi

.SS "void MotorEncoder::setDir (bool backward)"

.PP
Установить направление 
.PP
\fBАргументы\fP
.RS 4
\fIbackward\fP (true - нормально, false - реверс) 
.RE
.PP
.PP
.nf
19 { digitalWrite(PIN_DIR, backward ^ INVERTED); }
.fi

.SS "void MotorEncoder::setDirPWM (int16_t power)"

.PP
Установить шим-направление\&. Отрицательные значения соотвествуют реверсу\&. ШИМ берётся по модулю и ограничивается\&. 
.PP
\fBАргументы\fP
.RS 4
\fIpower\fP (-255\&.\&.255) 
.RE
.PP
.PP
.nf
23                                           {
24     setDir(power < 0);
25     power = abs(power);
26     setPWM(constrain(power, 0, 255));
27 }
.fi

.SS "void MotorEncoder::setPWM (uint8_t pwm)"

.PP
Установить шим 
.PP
\fBАргументы\fP
.RS 4
\fIpwm\fP ШИМ 0\&.\&.255 
.RE
.PP
.PP
.nf
21 { analogWrite(PIN_SPEED, pwm); }
.fi

.SS "void MotorEncoder::setSpeed (int16_t dtick)"

.PP
Установить целевую скорость вращения 
.PP
\fBАргументы\fP
.RS 4
\fIdtick\fP 
.RE
.PP
.PP
.nf
29 { speed = speed_set = constrain(dtick, \-PARAMS::MAX_DELTA_TICKS, PARAMS::MAX_DELTA_TICKS); }
.fi

.SS "void MotorEncoder::spin ()"

.PP
вращать мотор (вызывать постоянно) .PP
.nf
31                         {
32     setDirPWM(KP_SPEED * (next_pos \- position));
33     if (millis() <= timer) return;
34     timer = millis() + PARAMS::SPIN_PERIOD_MS;
35     next_pos += speed;
36     return;
37 }
.fi

.SH "Данные класса"
.PP 
.SS "volatile int32_t mosh::hardware::MotorEncoder::position = 0"


.SH "Автор"
.PP 
Автоматически создано Doxygen для MoshLib из исходного текста\&.
